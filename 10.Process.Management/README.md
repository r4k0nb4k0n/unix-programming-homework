# 10. 프로세스 관리
## 프로세스
* 프로세스
	* 실행중인 프로그램
	* 자원 소유, 상태를 가짐
* 프로세스 ID
	* **특정 시점**에서 프로세스의 유일한 식별자
	* 순차적으로 할당됨
		* 프로세스 `A`, `B`, `C`가 만들어지면 PID는 `A < B < C`(**항상 참은 아님**)
	* 특별한 프로세스 ID
		* 0번: `swapper`(또는 `idle`) process
			* 실행될 프로세스가 없을 때 커널이 실행하는 프로세스
		* 1번: `init` process
			* 시스템의 초기화 담당
			* 모든 프로세스의 조상 프로세스
## 프로세스의 계층 구조
* 리눅스의 프로세스는 부모 자식의 관계를 가짐
	* 부모: 프로세스를 생성해주는 프로세스
	* 자식: 생성된 프로세스
	* 모든 프로세스의 부모는 `init` 프로세스
	* 쉘에서 `pstree` 명령을 쳐볼 것
* 프로세스 그룹
	* 모든 프로세스는 프로세스 그룹을 가짐
	* 다른 프로세스와의 관계를 나타냄
		* 유사한 관계가 있는 프로세스를 한 그룹으로 묶음
* `pid_t`
	* 프로세스의 `id`를 표현하는 타입
	* 일반적으로 `typedef`를 통해 `int` 타입으로 정의됨
## 프로세스 스케줄링
* 하나의 CPU 코어는 한번에 한 개의 프로세스밖에 수행할 수 없음
![readylist](./ready_list.png?raw=true)
* 실제로는 그림보다 훨씬 복잡한 메커니즘으로 스케줄링 알고리즘이 실행됨
* 리눅스 2.6에서는 `O(1)` 스케줄러 사용
## Process 상태 전이
* 프로세스 상태의 분류
	* 사용자 모드(user mode)에서 수행중인 상태
	* 커널 모드(kernel mode)에서 수행중인 상태
	* 수행 대기 상태
	* 수면(sleeping) 상태
* 프로세스 상태의 전이
	* CPU를 시간분할에 따라 프로세스에 할당
	* 프로세스들은 위에 언급된 상태를 이동하며 실행
* 프로세스 상태 전이도
![process-status-tree](./process_status_tree.png?raw=true)
## Process 구조
* 프로세스에 필요한 자료구조
![process-data-structure](./process_data_structure.png?raw=true)
* 사용자 구조 (user structure, U-area)
	* 프로세스의 상태를 기술
	* 수행중인 프로세스가 접근해야 하는 필드를 가짐
	* 시스템 호출에 의해 리턴된 에러 코드 (`errno`)
	* 프로세스 테이블의 포인터
	* 프로세스에 의해 open된 file descriptor
	* TEXT, DATA, STACK의 크기
	* 사용자 모드와 커널 모드에서 수행된 시간
	* 파일 생성 마스크 (`umask`)
	* Real user ID, effective user ID
	* 현재 디렉토리, 루트 디렉토리 등
* 프로세스 테이블 (Process Table)
	* 프로세스의 상태를 기술
	* 프로세스 관리를 위하여 커널에 필요한 정보를 기술
	* 프로세스 상태(수면, 실행중, ...)
	* 프로세스 플래그(swap 상태, swap될 수 없는 상태 등)
	* 프로세스 우선순위
	* 부모 프로세스 ID
	* 사용자 구조(U-area)의 포인터
	* 알람 시그널이 발생하기까지 남은 시간
	* Swap 가능한 영역의 주소와 크기
## 프로세스 식별자(Process ID)
* [getpid](./getpid)
* [setuid, setgid, seteuid, setegid](./set_id)
## 실행 이미지 대체 및 프로세스의 생성
* 실행 이미지
	* 프로세스가 실행될 때 수행하는 코드 및 이와 관련된 자료구조를 의미
* 실행 이미지 대체
	* 현재 실행중인 프로세스의 실행이미지를 대체하는 과정
	* `exec` 계열의 함수를 이용
		* `execl()`, `execlp()`, `execvp()`, `execv()`, `execle()`, `execve()`
* 프로세스의 생성
	* `fork()`, `vfork()`
* 보통 새로운 프로그램을 실행시킬 때
	* [fork()](./fork)를 통해 프로세스를 생성하고 [exec()](./exec)을 통해 실행 이미지를 대체
* [프로세스의 생성(fork)](./fork)
* [실행 이미지의 대체(exec)](./exec)
* [exec을 위한 프로세스의 생성(vfork)](./vfork)
## Copy-On-Write
* `fork()`를 수행할 때의 불필요한 복사를 막기 위함
	* 자식 프로세스에게 부모가 가리키는 물리 메모리를 동일하게 가리키도록 함
	* 쓰기 발생 시 메모리 새로 할당 후 데이터 적음
	![Copy-On-Write](./copy_on_write.png?raw=true)
* 실제 동작은 앞의 예와는 약간 차이 존재
	* 공유하는 페이지에 데이터 쓰기 시 페이지 폴트 인터럽트 발생 후 새로운 페이지 할당
	* 이에 대한 자세한 내용은 운영체제 시간에 배우도록 할 것
	* 현재 거의 모든 운영체제에서 Copy-On-Write 지원
	* 추후 메모리 공유를 다룰 때에도 Copy-On-Write 개념이 소개될 예정임
## 프로세스의 종료(exit)
* 정상 종료
	* `main` 함수로부터의 리턴(`exit` 함수를 호출하는 것과 동일)
	* `exit` 또는 `_exit` 함수의 호출
		* 표준 C 라이브러리와 시스템 호출
	* 종료 상태 값을 명시적으로 지정
		* `return 0`, `exit(0)`, `exit(8)`
* 비정상 종료
	* 자신이 `abort()` 시스템 콜을 호출
	* 커널이 발생한 시그널(signal)에 의한 종료
		* `0`으로 나눈 경우, 잘못된 메모리 참조 등
	* 커널이 종료 상태값을 설정
* 프로세스의 종료 작업
	* 운영체제는 그 프로세스가 open한 file descriptor를 모두 close
	* 프로세스가 차지하고 있던 메모리를 가용 메모리 풀(pool)로 변환
	* `exit` 함수는 표준 입출력 정리 루틴을 수행하고 `_exit`를 호출
		* open된 file stream에 대해 `fclose` 호출, 버퍼에 남은 데이터를 `flush`
	* C 컴파일러는 `main` 함수에서 return하는 경우 자동적으로 `exit` 함수가 호출되도록 코드를 생성
* [exit](./exit)
## 프로세스에 대한 대기(wait)
* 자식 프로세스의 종료 확인
	* 자식 프로세스의 종료 상태 및 종료 시기를 얻어내는 방법
	* 프로세스 종료시 커널은 부모 프로세스에게 시그널(`SIGCHLD`)을 전송
	* 시그널에 의해 부모 프로세스는 block에서 해제됨
	* 부모 프로세스는 시그널을 무시하거나 규정된 동작을 하도록 할 수 있음
	* 종료된 자식의 pid 리턴
	* 자식이 여러 개일 경우 아무거나 한 개 정지할 때까지 기다림
* [wait](./wait)
## 프로세스에 대한 대기(waitpid)
* [waitpid](./waitpid)
## Orphaned, Zombie Process
* 고아(orphaned) 프로세스
	* 자식 프로세스가 종료하기 전에 부모 프로세스가 수행을 마친 경우의 자식 프로세스
	* 커널은 고아 프로세스를 찾아서 `init` 프로세스의 자식이 되도록 함
* 좀비(zombie) 프로세스
	* 종료했으나 부모 프로세스의 'wait' 처리가 끝나지 않은 프로세스
	* 커널이 프로세스 ID, 종료 상태 값, CPU 사용 시간 등의 정보를 유지
	* 지속적인 좀비 상태
## 새로운 프로그램의 실행
* [forkexec](./forkexec)
* [system](./system)
